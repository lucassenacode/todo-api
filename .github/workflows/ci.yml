# .github/workflows/ci.yml

name: API CI Pipeline

on:
  push:
    branches: [ "main", "develop" ]
  pull_request:
    branches: [ "main", "develop" ]

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest

    steps:
      # 1. Checkout do Código
      - name: Check out code
        uses: actions/checkout@v4

      # 2. Configurar o Python
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      # 3. Criar o ficheiro .env para o CI
      - name: Create .env file
        run: |
          echo "DB_USER=postgres" >> .env
          echo "DB_PASSWORD=supersecret" >> .env
          echo "DB_NAME=todo_db" >> .env
          echo "DB_HOST=db" >> .env
          echo "DB_PORT=5432" >> .env
          echo "TEST_DATABASE_URL=postgresql+psycopg2://postgres:supersecret@db:5432/todo_db_test" >> .env
          echo "JWT_SECRET_KEY=a7a0303126f31f9d4538116f4325c898b136b3b5c56c2f7c688c34e3f848b6f3" >> .env
          echo "JWT_ALGORITHM=HS256" >> .env
          echo "ACCESS_TOKEN_EXPIRE_MINUTES=30" >> .env
          echo "REFRESH_TOKEN_EXPIRE_DAYS=7" >> .env
          echo "MIGRATE_ON_START=true" >> .env

      # 4. Passo: Subir os Containers e Aguardar (A CORREÇÃO)
      # (Usamos '--wait' no 'up', como você sugeriu. O Docker Compose
      # não irá terminar este passo até que o 'healthcheck' do 'db' passe.)
      - name: Start Docker Compose and Wait 
        run: docker compose up -d --build --wait db api

      # 5. Passo: Executar os Testes
      # (Agora temos a garantia de que o 'db' está pronto)
      - name: Run Pytest
        run: docker compose exec -e PYTHONPATH=/app api python -m pytest